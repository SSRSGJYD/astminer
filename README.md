# astminer

A library for mining of [path-based representations of code](https://arxiv.org/pdf/1803.09544.pdf). The repo is forked from https://github.com/vovak/astminer.




## About
Currently it supports extraction of path-based representations and raw ASTs from code in Java, C/C++, Python and JavaScript. 

The default output format is inspired by [code2vec](https://github.com/tech-srl/code2vec).



## Usage

### Examples

A few [simple usage examples](src/main/kotlin/astminer/examples) can be run with `./gradlew run`.

A somewhat more verbose [example of usage in Java](src/main/kotlin/astminer/examples/AllJavaFiles.kt) is available as well.



### Parsing C/C++

For now C/C++ support is handled by wrapping [Joern](https://github.com/octopus-platform/joern) parser 
(in fact, by its [extended version](https://github.com/egor-bogomolov/joern)). 

You need to make a few extra steps to use astminer with C/C++ code:

* `scripts/joern/setup.sh` &ndash; download and build Joern (after this step you can use the wrapper);
* `scripts/joern/run.sh pathToDirectory` &ndash; process the directory recursively by Joern (if you want to use it separately from the wrapper); 
* `scripts/joern/clean.sh` &ndash; remove files generated by Joern;
* `scripts/joern/update.sh` &ndash; pull changes from the [repository](https://github.com/egor-bogomolov/joern) and rebuild Joern.

A [usage example](src/main/kotlin/astminer/examples/AllCppFiles.kt) is available.



### Parsing Python

Put your input data in `./py_data` , run 

```shell
./gradlew run
```

and output will be in `./py_output` .

There are 2 modes for parsing Python:

+ from scratch: in this mode, together with `path_contextcsv`,  `node_types.csv`, `paths.csv` and `tokens.csv` will also be generated . However, for different input files, same token, node and path may be represented in different id. You can modify an argument in `astminer/src/main/kotlin/astminer/Main.kt` :

  ```kotlin
  allPythonFiles(true)
  ```

  to run in this mode.

+ from existing dictionary: given `node_types.csv`, `paths.csv` and `tokens.csv` , you can use existing dictionary to generate `path_context.csv` . You can modify an argument in `astminer/src/main/kotlin/astminer/Main.kt` :

  ```kotlin
  allPythonFiles(false)
  ```

  to run in this mode. You need to place  `node_types.csv`, `paths.csv` and `tokens.csv` in `./py_input` .



### Parsing JavaScript

Put your input data in `./js_data` , run 

```shell
./gradlew run
```

and output will be in `./js_output` .

Similar to Python parser, you can also parse JavaScript in 2 modes. To run in the second mode, put your csv files in `./js_input` .



## Project Structure

```yaml
astminer:
|-- src
| 	|-- main
| 	|	|-- antlr
| 	|	|	| 	Java8Lexer.g4
| 	|	|	| 	Java8Parser.g4
| 	|	|	└--	Python3.g4
| 	|	|   generated
| 	|	|   java
| 	|	└-- kotlin: generate path-contexts
| 	└-- test
|
|-- data: dir for input code files/folders
|-- input: dir for exisiting dictionary
└-- output: dir for output files, should contain 4 cvs files
```



### Mechanism in `/src/main/kotlin/astminer`

The main worker is written in `kotlin`.

`VocabularyPathStorage` class in `/paths/VocabularyPathStorage` file is the worker of saving generated information by default.

`RegistratedPathStorage` class in `/paths/RegistratedPathStorage` file is used as the worker of saving generated information when generating using existing vocabulary.

Files in `/examples` show the usages of extracting Path-contexts from code of several languages. 



## Other languages

Support for a new programming language can be implemented in a few simple steps:
1. Add the corresponding [ANTLR4 grammar file](https://github.com/antlr/grammars-v4) to the `antlr` directory;
2. Run the `antlr4` Gradle task to generate the parser;
3. Implement a very minimal wrapper around the generated parser.
See [JavaParser](src/main/kotlin/astminer/parse/antlr/java/JavaParser.kt) or [PythonParser](src/main/kotlin/astminer/parse/antlr/python/PythonParser.kt) for an example of a wrapper.
